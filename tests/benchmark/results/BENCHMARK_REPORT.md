# XDP DNS Filter 性能对比报告

## 📊 测试环境

| 项目 | 值 |
|------|-----|
| **CPU** | 13th Gen Intel(R) Core(TM) i7-1360P |
| **核心数** | 8核16线程 |
| **内存** | 7.6 GB |
| **OS** | Linux (Ubuntu 22.04) |
| **Go 版本** | go1.23.3 linux/amd64 |
| **GCC 版本** | g++ 11.4.0 |
| **C++ 标准** | C++17 |
| **编译优化** | -O3 -march=native -flto |

---

## 🚀 单操作性能对比

### DNS 解析性能 (纯库调用)

| 操作 | Go | C++ (纯) | **提升倍数** |
|------|-----|-----|:------------:|
| DNS Parse | 770 ns | **12 ns** | **64x** ⬆️ |
| Domain Decode | ~770 ns | **59 ns** | **13x** ⬆️ |

### 响应构建性能 (纯库调用)

| 操作 | Go | C++ (纯) | **提升倍数** |
|------|-----|-----|:------------:|
| Build NXDOMAIN | 1226 ns | **24 ns** | **51x** ⬆️ |
| Build A Response | 2205 ns | **3.5 ns** | **630x** ⬆️ |

### 域名匹配性能 (Trie)

| 操作 | Go | C++ | 对比 |
|------|-----|-----|:----:|
| Trie Match (1000 rules) | **160 ns** | 359 ns | Go 快 2.2x |
| Trie Wildcard Match | **160 ns** | 312 ns | Go 快 1.9x |

---

## 📈 端到端性能对比

### 纯 Go 实现 (当前)

| 场景 | 延迟 | 内存分配 | 吞吐量预估 |
|------|------|---------|-----------|
| Allow (解析+匹配) | 715 ns | 10 allocs | 1.4M/s |
| Block (解析+匹配+响应) | 2125 ns | 35 allocs | 0.47M/s |
| Redirect (解析+匹配+响应) | 3174 ns | 71 allocs | 0.32M/s |
| 大规则集匹配 (1000条) | 848 ns | 10 allocs | 1.2M/s |

### 混合架构 (C++ 解析/响应 + Go 匹配)

| 场景 | 延迟 | 内存分配 | 吞吐量预估 |
|------|------|---------|-----------|
| Allow (C++解析 + Go匹配) | 621 ns | 6 allocs | 1.6M/s |
| Block (全混合) | 724 ns | 8 allocs | 1.4M/s |
| 端到端处理 | 760 ns | 8 allocs | 1.3M/s |

**注意**: CGO 调用开销约 100-200ns，抵消了部分 C++ 性能优势。

---

## 🔍 关键发现

### ✅ C++ 优势 (纯库调用)

1. **DNS 解析: 64倍提升** (12ns vs 770ns)
2. **响应构建: 51-630倍提升** (3.5-24ns vs 1200-2200ns)
3. **零内存分配**: 热路径无 GC 压力

### ⚠️ CGO 开销

1. **每次 CGO 调用约 100-200ns 开销**
2. **内存拷贝**: 需要在 Go 和 C++ 之间传递数据
3. **实际端到端提升约 1.4-3x** (而非单操作的 50-600x)

### ✅ Go 优势 (保留使用)

1. **Trie 匹配: 2倍更快** (160ns vs 312-359ns)
2. **无 CGO 开销**: 纯 Go 调用无额外开销
3. **开发效率**: 代码简洁易维护

---

## 💡 推荐架构

### 当前推荐: 纯 Go (简单场景)

对于 <1M PPS 的场景，纯 Go 实现已足够:

```
DNS 包 → Go 解析 (770ns) → Go Trie 匹配 (160ns) → Go 响应构建 (1200ns)
总延迟: ~2100ns, 吞吐量: ~500K PPS
```

### 高性能场景: 混合架构

对于需要更高吞吐量的场景:

```
┌─────────────────────────────────────────────────┐
│              Go 控制面                          │
│  • 配置管理  • 规则加载  • Metrics • HTTP API   │
└─────────────────────┬───────────────────────────┘
                      │
┌─────────────────────▼───────────────────────────┐
│           混合数据面 (推荐)                      │
│  • C++ DNS 解析 (12ns)                          │
│  • Go Trie 匹配 (160ns)  ← Go 更快!             │
│  • C++ 响应构建 (24ns)                          │
└─────────────────────────────────────────────────┘

总延迟: ~720ns, 吞吐量: ~1.4M PPS
```

### 极致性能: 纯 C++ 数据面

完全避免 CGO 开销:

```
• 批量处理减少 CGO 调用次数
• 使用共享内存传递数据
• 预期吞吐量: 5M+ PPS
```

---

## 📝 结论

1. **C++ 单操作性能优势巨大** (50-600倍)
2. **CGO 开销显著** (每次调用 100-200ns)
3. **Go Trie 匹配更优** (2倍)
4. **混合架构端到端提升约 1.4-3x**
5. **对于极致性能，考虑批量处理或纯 C++ 数据面**

